// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")

}
// User model for authentication (local + OAuth)
model User {
  id          Int       @id @default(autoincrement())
  email       String    @unique
  password    String?   // Hashed password for local auth; optional for OAuth-only users
  provider    String?   // e.g., 'google', 'facebook', 'local' for OAuth provider
  providerId  String?   // Unique ID from OAuth provider (e.g., Google's user ID)
  name        String?
   picture     String?   // ðŸ‘ˆ ADD THIS
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  videos      Video[]   // One-to-many: User owns multiple videos
  userPlatforms UserPlatform[]  // One-to-many: User has API keys for platforms
  subscriptions Subscription[]  // One-to-many: User has subscription history
  @@unique([provider, providerId])
}

// Video model: The original long video uploaded or linked
model Video {
  id               Int      @id @default(autoincrement())
  userId           Int
  title            String?  // e.g., "My Podcast Episode #1"
  description      String?  // Optional long description
  sourceType       String   @default("youtube") // 'youtube' or 'upload'
  sourceUrl              String   // YouTube URL or file path (S3, local, etc.)
  thumbnail        String?  // Preview image URL
  duration         Int?     // In seconds (extracted later)
  fileSize         BigInt?  // In bytes (for uploaded files)
  status           String   @default("pending") // pending, processing, completed, failed
  processingError  String?  // If status = 'failed', store reason

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  clips            Clip[]   // Future clips generated from this video

  @@index([userId])
  @@index([status])           // Optional: faster filtering by status
}

// Clip model: Generated short clips from the video
model Clip {
  id        Int      @id @default(autoincrement())
  videoId   Int
  clipUrl   String
  platform  String

  title     String?
  startTime Int
  endTime   Int
  duration  Int

  postedAt  DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  video     Video     @relation(fields: [videoId], references: [id], onDelete: Cascade)
  earnings  Earning[]
}


// Earning model: Tracked revenue from clips
model Earning {
  id        Int       @id @default(autoincrement())
  clipId    Int
  amount    Float     // e.g., 42.50 (in USD)
  date      DateTime  // When the earning was recorded
  source    String?   // Optional: e.g., 'ad_share', 'tips'
  createdAt DateTime  @default(now())
  clip      Clip      @relation(fields: [clipId], references: [id], onDelete: Cascade)
}

// UserPlatform model: Per-user API keys for social platforms (e.g., for auto-posting)
model UserPlatform {
  id        Int       @id @default(autoincrement())
  userId    Int
  platform  String    // e.g., 'tiktok', 'instagram', 'youtube'
  apiKey    String?   // User's API key/token for the platform
  refreshToken String? // For OAuth tokens that need refreshing
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Subscription model: For SaaS plans (e.g., Solo $49/mo, Agency $299/mo)
model Subscription {
  id        Int       @id @default(autoincrement())
  userId    Int
  plan      String    // e.g., 'solo', 'agency'
  status    String    // e.g., 'active', 'canceled', 'trial'
  startDate DateTime
  endDate   DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}